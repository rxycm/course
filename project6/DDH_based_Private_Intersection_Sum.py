import hashlib
import random
import math
from typing import List, Tuple
from math import gcd
from tinyec import registry
from tinyec.ec import Point


# hashing H:U->G

def hash_to_scalar(s: str, curve) -> int:
    h = hashlib.sha256(s.encode()).digest()
    i = int.from_bytes(h, 'big')
    return i % curve.field.n


def hash_to_point(s: str, curve) -> Point:
    return curve.g * hash_to_scalar(s, curve)

# Miller-Rabin primality test

def is_probable_prime(n: int, k: int = 8) -> bool:
    if n < 2:
        return False
    small_primes = [2,3,5,7,11,13,17,19,23,29]
    for p in small_primes:
        if n % p == 0:
            return n == p
    # write n-1 as d*2^s
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1
    for _ in range(k):
        a = random.randrange(2, n-1)
        x = pow(a, d, n)
        if x == 1 or x == n-1:
            continue
        for _ in range(s-1):
            x = (x * x) % n
            if x == n-1:
                break
        else:
            return False
    return True


def gen_prime(bits:int) -> int:
    while True:
        p = random.getrandbits(bits)
        p |= (1 << bits-1) | 1
        if is_probable_prime(p):
            return p


def lcm(a:int,b:int)->int:
    return a//gcd(a,b)*b

# Paillier Cryptosystem
class Paillier:
    def __init__(self, bits: int = 512):
        self.bits = bits
        self.pubkey = None
        self.privkey = None
        self.keygen(bits)

    def keygen(self, bits: int = 512):
        p = gen_prime(bits//2)
        q = gen_prime(bits//2)
        while q == p:
            q = gen_prime(bits//2)
        n = p * q
        nsq = n * n
        g = n + 1  
        lam = lcm(p-1, q-1)
        def L(u):
            return (u - 1) // n
        u = pow(g, lam, nsq)
        lu = L(u)
        mu = pow(lu, -1, n)
        self.pubkey = (n, g)
        self.privkey = (lam, mu)

    def encrypt(self, m: int) -> int:
        n, g = self.pubkey
        nsq = n * n
        if not (0 <= m < n):
            m = m % n
        while True:
            r = random.randrange(1, n)
            if math.gcd(r, n) == 1:
                break
        c = (pow(g, m, nsq) * pow(r, n, nsq)) % nsq
        return c

    def decrypt(self, c: int) -> int:
        n, g = self.pubkey
        lam, mu = self.privkey
        nsq = n * n
        def L(u):
            return (u - 1) // n
        u = pow(c, lam, nsq)
        m = (L(u) * mu) % n
        return m

    @staticmethod
    def add(c1:int, c2:int, n:int) -> int:
        nsq = n*n
        return (c1 * c2) % nsq

    @staticmethod
    def scalar_mult(c:int, k:int, n:int) -> int:
        nsq = n*n
        return pow(c, k, nsq)

# PIS Protocol using Paillier

def pt_to_bytes(Pt: Point) -> bytes:
    if Pt.x is None:
        return b'INF'
    return Pt.x.to_bytes((Pt.x.bit_length()+7)//8, 'big') + Pt.y.to_bytes((Pt.y.bit_length()+7)//8, 'big')

def PIS(P1_ids: List[str], P2_pairs: List[Tuple[str,int]], curve_name='secp256r1', paillier_bits:int=512):
    curve = registry.get_curve(curve_name)
    order = curve.field.n

    # Setup random exponents k1,k2 and Paillier keypair (generated by P2)
    k1 = random.randrange(1, order)
    k2 = random.randrange(1, order)
    HE = Paillier(bits=paillier_bits)
    n, g = HE.pubkey

    # Round 1: P1 computes H(vi)^{k1}
    A = [ (hash_to_point(v, curve) * k1) for v in P1_ids ]
    random.shuffle(A)

    # Round 2: P2 exponentiates by k2 and also prepares encrypted values
    Z = [a * k2 for a in A]
    random.shuffle(Z)

    B_pairs = []
    for (w, t) in P2_pairs:
        Hw_k2 = (hash_to_point(w, curve)) * k2
        ct = HE.encrypt(t)
        B_pairs.append((Hw_k2, ct))
    random.shuffle(B_pairs)

    # Round 3: P1 raises Hw_k2 to k1 -> Hw^{k1 k2} and checks membership in Z
    Zset = set(pt_to_bytes(z) for z in Z)
    sum_ct = None
    match_count = 0
    for Hw_k2, ct in B_pairs:
        Hw_k1k2 = Hw_k2 * k1
        if pt_to_bytes(Hw_k1k2) in Zset:
            match_count += 1
            if sum_ct is None:
                sum_ct = ct
            else:
                sum_ct = Paillier.add(sum_ct, ct, n)
    if sum_ct is None:
        sum_ct = HE.encrypt(0)

    # P1 re-randomizes ciphertext by multiplying with an encryption of 0 (i.e., multiply by g^{0}*r^n)
    zero_enc = HE.encrypt(0)
    sum_ct = Paillier.add(sum_ct, zero_enc, n)

    # P2 decrypts
    intersection_sum = HE.decrypt(sum_ct)
    return match_count, intersection_sum


    
# Example usage
if __name__ == '__main__':
    P1 = [f'user{i}' for i in range(1,10)]
    P2 = [(f'user{i}', i) for i in range(5,13)]

    print('---PIS Protocol Example---')
    print('P1 IDs:', P1)
    print('P2 (ID, value) pairs:', P2)

    c, s = PIS(P1, P2, paillier_bits=2048)
    print('Intersection cardinality (expected 5):', c)
    print('Intersection sum (expected 35):', s)
