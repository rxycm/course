# Project1说明文档

本项目实现了国密对称加密算法 **SM4** 及其 **GCM（Galois/Counter Mode）** 认证加密模式的完整 C 语言程序，包含以下部分：

- SM4 算法
- 查找表优化
- 使用 SIMD (AVX2) 的 SM4 并行加速实现
- 基于 SM4 的 GCM 加密与认证模式

---

## 1. SM4 算法

SM4 是中国国家密码管理局发布的区块对称加密算法，属于非平衡Feistel 结构，特点如下：

- **分组长度**：128 位（16 字节）
- **密钥长度**：128 位（16 字节）
- **轮数**：32 轮
- **核心操作**：S盒代换 + 线性变换（L）+ 密钥扩展

SM4 的轮函数如下：

```
F(X0, X1, X2, X3, rk) = X0 ^ T(X1 ⊕ X2 ⊕ X3 ⊕ rk)
```

其中 `T()` 是非线性变换，包括 S 盒和线性变换。

---

## 2. 查找表优化原理（S盒 + L变换融合）

为了提升 SM4 中非线性变换 `T(x)` 的效率，项目采用 **查表融合优化技术**，将 S 盒代换和线性变换 L 合并成预计算表，从而加快处理速度，具体如下：

### 原始操作流程：

输入 `x` 是 32 位数据，可以分成 4 个字节：

```
x = (x0 << 24) | (x1 << 16) | (x2 << 8) | x3
```

其中每个 `xi` 为 8bit，先进行 S盒变换：

```
S(x0), S(x1), S(x2), S(x3)
```

再进行线性变换 `L`：

```
L(S(x0)<<24 ^ S(x1)<<16 ^ S(x2)<<8 ^ S(x3))
```

### 表驱动优化策略：

将 `S` 和 `L` 合并预处理为 4 个查找表 `T0 ~ T3`：

```c
T0[x] = L(S(x) << 24)
T1[x] = L(S(x) << 16)
T2[x] = L(S(x) << 8)
T3[x] = L(S(x))
```

这样可以将 `T(x)` 表达为：

```
T(x) = T0[x0] ^ T1[x1] ^ T2[x2] ^ T3[x3]
```

### 优势：

- 避免每轮重复计算 S 盒 + 循环移位 + 异或
- 替换为快速查表 + 异或组合
- 可进一步并行化支持 SIMD 操作

### 轮函数变换流程：

```
X0, X1, X2, X3 ← 明文块（4个32位）
for i = 0 to 31:
    Ki ← 第 i 轮轮密钥
    Tmp ← X1 ⊕ X2 ⊕ X3 ⊕ Ki
    Tmp ← T(Tmp)      // 使用查表优化的 T 表达式
    Tmp ← X0 ^ Tmp
    X0, X1, X2, X3 ← X1, X2, X3, Tmp
输出密文 ← X3, X2, X1, X0
```

---

## 3. SIMD（AVX2）并行加速实现详解

### 并行输入与加载

本项目的 `encrypt()` 函数使用 AVX2 一次性处理 **8 个 128-bit 分组（总计 128 字节）**，通过 `__m256i` 向量寄存器并行操作：

```c
__m256i X[4];  // X0, X1, X2, X3，并行保存8个分组的每轮中间状态
```

- 将明文划分为 8 个块，每块 16 字节，对应 4 个 32bit 整数（X0~X3）
- 使用 `_mm256_loadu_si256` 读取 256-bit 数据到 SIMD 寄存器

### 并行轮函数运算

对于每一轮：

1. 执行 `X1 ^ X2 ^ X3 ^ rk` 的并行异或操作
2. 将每个 32bit 元素中的每字节提取出来，查表得到 `T0..T3` 值（通过 `_mm256_set_epi32` 构建）
3. 汇总为 `T(x)` 结果并异或 X0 得到下一轮输出

这一过程使用 `_mm256_shuffle_epi8` + `_mm256_xor_si256` 完成每轮的状态更新。

### 状态迁移与循环

每轮结束后，更新 `X0 ← X1, X1 ← X2, X2 ← X3, X3 ← Tmp`，在 SIMD 中通过寄存器重新赋值完成。

```c
X[0] = X[1];
X[1] = X[2];
X[2] = X[3];
X[3] = tmp;
```

循环 32 轮后，将最终的 `X[3], X[2], X[1], X[0]` 输出为加密密文。

### 性能优势

- 每轮处理 8 个数据块，提升吞吐量 8 倍
- 所有计算（查找表、移位、异或）都在向量级别并行处理
  
  

---

## 4. GCM 模式实现

本项目实现了基于 SM4 的 GCM 模式：

- **GCM 特点**：结合 Counter 加密模式 + GHASH 的认证机制
- **支持参数**：96-bit IV，128字节明文块，AAD
- **核心函数**：
  - `gcm_encrypt(...)`
  - `gcm_decrypt(...)`

### 加密流程：

1. 生成密钥流：加密 `IV || counter`（8组）得到 128 字节 keystream
2. `ciphertext = plaintext XOR keystream`
3. 使用 `GHASH` 认证 `AAD` + `ciphertext`，输出 tag
4. 最终 `tag = GHASH_result XOR E_K(Y0)`

### 解密流程：

1. 同样生成 keystream 恢复明文
2. 重新计算 GHASH，对比 tag 验证完整性

---

## 5. 文件结构

```
├── sm4.h             // SM4 接口头文件
├── sm4.c             // SM4 算法优化实现(无优化版本放在注释中)
├── sm4_gcm.c         // GCM模式实现
├── main.c            // 测试加解密
```

---

## 
